// This file is autogenerated by {{ template }}

use std::collections::HashMap;

use lib_ruby_parser::nodes::*;

use crate::ast::NodeRef;

pub struct Processor<'ast> {
    pub parents: HashMap<NodeRef<'ast>, NodeRef<'ast>>,
}

impl<'ast> Processor<'ast> {
    pub fn process(&mut self, node: &'ast Node) {
        match node {
            {% for node in nodes -%}
            Node::{{ node.camelcase_name }}(inner) => {
                self.process_{{ node.camelcase_name | camelcase_to_snakecase }}(inner);
            }
            {% endfor %}
        }
    }

    {% for node in nodes %}
    #[allow(unused_variables)]
    fn process_{{ node.camelcase_name | camelcase_to_snakecase }}(&mut self, node: &'ast {{ node.camelcase_name }}) {
        {% for field in node.fields %}
        {%- assign field_name = field.snakecase_name | escape_rust_keyword -%}

        {% case field.field_type %}
        {%- when "Node" -%}
            self.parents.insert(NodeRef::from(node.{{ field_name }}.as_ref()), NodeRef::{{ node.camelcase_name }}(node));
            self.process(&node.{{ field_name }});
        {%- when "Nodes" -%}
            for item in &node.{{ field_name }} {
                self.parents.insert(NodeRef::from(item), NodeRef::{{ node.camelcase_name }}(node));
                self.process(item);
            }
        {%- when "MaybeNode" or "RegexpOptions" -%}
            if let Some(inner) = node.{{ field_name }}.as_deref() {
                self.parents.insert(NodeRef::from(inner), NodeRef::{{ node.camelcase_name }}(node));
                self.process(inner);
            }
        {%- when "Loc" or "MaybeLoc" or "Str" or "RawStr" or "MaybeStr" or "Chars" or "StringValue" or "U8" -%}
            // skip {{ field_name }}
        {%- else -%}
            compile_error!("Unsupported node field type {{ field.field_type }}");
        {% endcase %}
        {% endfor %}
    }
    {% endfor %}
}
