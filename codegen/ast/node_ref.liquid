// This file is autogenerated by {{ template }}

use lib_ruby_parser::nodes::*;

pub enum NodeRef<'ast> {
    {% for node in nodes %}
    {{ node.camelcase_name }}(&'ast {{ node.camelcase_name }}),
    {% endfor %}
}

impl<'ast> From<&'ast Node> for NodeRef<'ast> {
    fn from(value: &'ast Node) -> Self {
        match value {
            {% for node in nodes %}
            Node::{{ node.camelcase_name }}(inner) => Self::{{ node.camelcase_name }}(inner),
            {% endfor %}
        }
    }
}

impl Copy for NodeRef<'_> {}

impl Clone for NodeRef<'_> {
    fn clone(&self) -> Self {
        match self {
            {% for node in nodes %}
            Self::{{ node.camelcase_name }}(inner) => Self::{{ node.camelcase_name }}(inner),
            {% endfor %}
        }
    }
}

impl Eq for NodeRef<'_> {}

impl PartialEq for NodeRef<'_> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            // FIXME: std::ptr::eq(a, b)
            {% for node in nodes %}
            (Self::{{ node.camelcase_name }}(a), Self::{{ node.camelcase_name }}(b)) => a == b,
            {% endfor %}
            _ => false,
        }
    }
}

impl PartialEq<Node> for NodeRef<'_> {
    fn eq(&self, other: &Node) -> bool {
        match (self, other) {
            {% for node in nodes %}
            (Self::{{ node.camelcase_name }}(a), Node::{{ node.camelcase_name }}(b)) => *a == b,
            {% endfor %}
            _ => false,
        }
    }
}

impl std::hash::Hash for NodeRef<'_> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        match self {
            // FIXME: std::ptr::hash(inner, state)
            {% for node in nodes %}
            Self::{{ node.camelcase_name }}(inner) => {
                inner.expression_l.begin.hash(state);
                inner.expression_l.end.hash(state);
            }
            {% endfor %}
        }
    }
}

impl<'ast> std::fmt::Debug for NodeRef<'ast> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            {% for node in nodes %}
            Self::{{ node.camelcase_name }}(inner) => write!(f, "{{ node.camelcase_name }}({inner:p})"),
            {% endfor %}
        }
    }
}

{% for node in nodes %}
impl<'ast> From<&'ast {{ node.camelcase_name }}> for NodeRef<'ast> {
    fn from(value: &'ast {{ node.camelcase_name }}) -> Self {
        Self::{{ node.camelcase_name }}(value)
    }
}
{% endfor %}

{% for node in nodes %}
impl PartialEq<{{ node.camelcase_name }}> for NodeRef<'_> {
    fn eq(&self, other: &{{ node.camelcase_name }}) -> bool {
        match self {
            Self::{{ node.camelcase_name }}(inner) => *inner == other,
            _ => false,
        }
    }
}
{% endfor %}

/*
impl NodeRef<'_> {
{% for node in nodes %}
    {% assign snakecase_name = node.camelcase_name | camelcase_to_snakecase %}
    {% if snakecase_name == "self_" %}
    {% assign snakecase_name = "self" %}
    {% endif %}
    pub fn is_{{ snakecase_name }}_type(self) -> bool {
        matches!(self, Self::{{ node.camelcase_name }}(_))
    }
{% endfor %}
}
*/
